import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';

import '../core/constants/app_constants.dart';
import '../features/chat/domain/models/chat_session.dart';
import '../features/chat/domain/models/chat_message.dart';
import '../features/chat/domain/models/system_prompt.dart';
import '../core/constants/system_prompt_presets.dart';

class StorageService {
  late Box<ChatSession> _chatBox;
  late Box<SystemPrompt> _systemPromptBox;
  late Box _settingsBox;

  // Cache for sorted chat sessions
  List<ChatSession>? _cachedSessions;

  Future<void> init() async {
    await Hive.initFlutter();

    // Adapters will be generated by build_runner
    Hive.registerAdapter(ChatMessageAdapter());
    Hive.registerAdapter(ChatSessionAdapter());
    Hive.registerAdapter(SystemPromptAdapter());

    _chatBox = await Hive.openBox<ChatSession>(AppConstants.chatBoxName);
    _systemPromptBox = await Hive.openBox<SystemPrompt>(
      AppConstants.systemPromptsBoxName,
    );
    _settingsBox = await Hive.openBox(AppConstants.settingsBoxName);

    // Seed system prompts if empty
    if (_systemPromptBox.isEmpty) {
      final initialPrompts = SystemPromptPresets.getInitialPrompts();
      await _systemPromptBox.putAll({
        for (final prompt in initialPrompts) prompt.id: prompt,
      });
    }

    // Update cache when chat box changes
    _chatBox.watch().listen(_onChatBoxEvent);
  }

  void _onChatBoxEvent(BoxEvent event) {
    if (_cachedSessions == null) return;

    if (event.deleted) {
      _cachedSessions!.removeWhere((session) => session.id == event.key);
    } else if (event.value != null) {
      final ChatSession updatedSession = event.value as ChatSession;
      final index = _cachedSessions!
          .indexWhere((session) => session.id == updatedSession.id);

      if (index != -1) {
        final oldSession = _cachedSessions![index];
        _cachedSessions![index] = updatedSession;

        // Only resort if sort key changed
        if (updatedSession.createdAt != oldSession.createdAt) {
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      } else {
        _cachedSessions!.add(updatedSession);
        _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      }
    }
  }

  ValueListenable<Box<ChatSession>> get chatBoxListenable =>
      _chatBox.listenable();

  // Chats
  List<ChatSession> getChatSessions() {
    if (_cachedSessions != null) {
      return UnmodifiableListView(_cachedSessions!);
    }

    _cachedSessions = _chatBox.values.toList()
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));

    return UnmodifiableListView(_cachedSessions!);
  }

  Future<void> saveChatSession(ChatSession session) async {
    // Optimistic update for immediate UI response
    if (_cachedSessions != null) {
      final index =
          _cachedSessions!.indexWhere((s) => s.id == session.id);
      if (index != -1) {
        _cachedSessions![index] = session;
        // Assume createdAt didn't change for optimization in save path
      } else {
        // If it's a new session, it's likely the newest, so insert at top
        if (_cachedSessions!.isEmpty ||
            session.createdAt.isAfter(_cachedSessions!.first.createdAt) ||
            session.createdAt.isAtSameMomentAs(_cachedSessions!.first.createdAt)) {
          _cachedSessions!.insert(0, session);
        } else {
          _cachedSessions!.add(session);
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      }
    }
    await _chatBox.put(session.id, session);
  }

  Future<void> deleteChatSession(String id) async {
    // Optimistic update
    if (_cachedSessions != null) {
      _cachedSessions!.removeWhere((s) => s.id == id);
    }
    await _chatBox.delete(id);
  }

  Future<void> clearAllChats() async {
    _cachedSessions = null;
    await _chatBox.clear();
  }

  ChatSession? getChatSession(String id) {
    return _chatBox.get(id);
  }

  // System Prompts
  ValueListenable<Box<SystemPrompt>> get promptBoxListenable =>
      _systemPromptBox.listenable();

  List<SystemPrompt> getSystemPrompts() {
    return _systemPromptBox.values.toList();
  }

  // Search & Filter
  List<ChatSession> searchSessions({
    String query = '',
    String? model,
    DateTime? fromDate,
  }) {
    List<ChatSession> results = getChatSessions();

    // 1. Filter by Query (Title)
    if (query.isNotEmpty) {
      final lowerQuery = query.toLowerCase();
      results = results.where((s) {
        return s.title.toLowerCase().contains(lowerQuery);
      }).toList();
    }

    // 2. Filter by Model
    if (model != null && model.isNotEmpty) {
      results = results.where((s) => s.model == model).toList();
    }

    // 3. Filter by Date
    if (fromDate != null) {
      results = results.where((s) => s.createdAt.isAfter(fromDate)).toList();
    }

    return results;
  }

  Set<String> getAvailableModels() {
    return getChatSessions().map((s) => s.model).toSet();
  }

  Future<void> saveSystemPrompt(SystemPrompt prompt) async {
    await _systemPromptBox.put(prompt.id, prompt);
  }

  Future<void> deleteSystemPrompt(String id) async {
    await _systemPromptBox.delete(id);
  }

  // Settings
  Future<void> saveSetting(String key, dynamic value) async {
    await _settingsBox.put(key, value);
  }

  dynamic getSetting(String key, {dynamic defaultValue}) {
    return _settingsBox.get(key, defaultValue: defaultValue);
  }

  // Export
  Map<String, dynamic> exportData({
    bool includeChats = true,
    bool includePrompts = true,
  }) {
    final Map<String, dynamic> data = {
      'version': 1,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (includeChats) {
      data['chats'] = getChatSessions().map((s) => _chatSessionToJson(s)).toList();
    }

    if (includePrompts) {
      data['prompts'] = getSystemPrompts().map((p) => _systemPromptToJson(p)).toList();
    }

    return data;
  }

  Map<String, dynamic> _chatSessionToJson(ChatSession session) {
    return {
      'id': session.id,
      'title': session.title,
      'model': session.model,
      'messages': session.messages.map((m) => _chatMessageToJson(m)).toList(),
      'createdAt': session.createdAt.toIso8601String(),
      'systemPrompt': session.systemPrompt,
      'temperature': session.temperature,
      'topP': session.topP,
      'topK': session.topK,
    };
  }

  Map<String, dynamic> _chatMessageToJson(ChatMessage message) {
    return {
      'role': message.role,
      'content': message.content,
      'timestamp': message.timestamp.toIso8601String(),
      'images': message.images,
    };
  }

  Map<String, dynamic> _systemPromptToJson(SystemPrompt prompt) {
    return {
      'id': prompt.id,
      'title': prompt.title,
      'content': prompt.content,
    };
  }

  // Import
  Future<Map<String, int>> importData(Map<String, dynamic> data) async {
    int chatsImported = 0;
    int promptsImported = 0;

    if (data['chats'] != null) {
      final List chats = data['chats'];
      for (final chatData in chats) {
        try {
          final session = _chatSessionFromJson(chatData);
          await saveChatSession(session);
          chatsImported++;
        } catch (e) {
          debugPrint('Error importing chat: $e');
        }
      }
    }

    if (data['prompts'] != null) {
      final List prompts = data['prompts'];
      for (final promptData in prompts) {
        try {
          final prompt = _systemPromptFromJson(promptData);
          await saveSystemPrompt(prompt);
          promptsImported++;
        } catch (e) {
          debugPrint('Error importing prompt: $e');
        }
      }
    }

    return {'chats': chatsImported, 'prompts': promptsImported};
  }

  ChatSession _chatSessionFromJson(Map<String, dynamic> json) {
    return ChatSession(
      id: json['id'],
      title: json['title'],
      model: json['model'],
      messages: (json['messages'] as List)
          .map((m) => _chatMessageFromJson(m))
          .toList(),
      createdAt: DateTime.parse(json['createdAt']),
      systemPrompt: json['systemPrompt'],
      temperature: json['temperature']?.toDouble(),
      topP: json['topP']?.toDouble(),
      topK: json['topK']?.toInt(),
    );
  }

  ChatMessage _chatMessageFromJson(Map<String, dynamic> json) {
    return ChatMessage(
      role: json['role'],
      content: json['content'],
      timestamp: DateTime.parse(json['timestamp']),
      images:
          json['images'] != null ? List<String>.from(json['images']) : null,
    );
  }

  SystemPrompt _systemPromptFromJson(Map<String, dynamic> json) {
    return SystemPrompt(
      id: json['id'],
      title: json['title'],
      content: json['content'],
    );
  }
}
