import 'dart:collection';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:uuid/uuid.dart';

import '../core/constants/app_constants.dart';
import '../features/chat/domain/models/chat_session.dart';
import '../features/chat/domain/models/chat_message.dart';
import '../features/chat/domain/models/starred_message.dart';
import '../features/chat/domain/models/system_prompt.dart';
import '../core/constants/system_prompt_presets.dart';
import 'pdf_export_service.dart';
import 'dart:typed_data';

class StorageService {
  late Box<ChatSession> _chatBox;
  late Box<SystemPrompt> _systemPromptBox;
  late Box _settingsBox;
  late Box _activityLogBox;

  // Cache for sorted chat sessions
  List<ChatSession>? _cachedSessions;
  // Cache for chat tags
  Map<String, List<String>>? _cachedTags;
  // Cache for starred messages (O(1) lookup)
  Set<ChatMessage>? _cachedStarredMessages;

  // Whitelist of keys allowed for import/export
  static final Set<String> allowedSettingsKeys = {
    AppConstants.ollamaBaseUrlKey,
    AppConstants.themeModeKey,
    AppConstants.autoSaveChatsKey,
    AppConstants.hapticFeedbackKey,
    AppConstants.defaultModelKey,
    AppConstants.userMsgColorKey,
    AppConstants.aiMsgColorKey,
    AppConstants.bubbleRadiusKey,
    AppConstants.fontSizeKey,
    AppConstants.chatPaddingKey,
    AppConstants.showAvatarsKey,
    AppConstants.bubbleElevationKey,
    AppConstants.msgOpacityKey,
    AppConstants.customBgColorKey,
    AppConstants.promptEnhancerModelKey,
    AppConstants.pinnedChatsKey,
    AppConstants.archivedChatsKey,
    AppConstants.chatTagsKey,
    AppConstants.starredMessagesKey,
  };

  Future<void> init() async {
    await Hive.initFlutter();

    // Adapters will be generated by build_runner
    Hive.registerAdapter(ChatMessageAdapter());
    Hive.registerAdapter(ChatSessionAdapter());
    Hive.registerAdapter(SystemPromptAdapter());

    _chatBox = await Hive.openBox<ChatSession>(AppConstants.chatBoxName);
    _systemPromptBox = await Hive.openBox<SystemPrompt>(
      AppConstants.systemPromptsBoxName,
    );
    _settingsBox = await Hive.openBox(AppConstants.settingsBoxName);
    _activityLogBox = await Hive.openBox(AppConstants.activityLogBoxName);

    // Seed system prompts if empty
    if (_systemPromptBox.isEmpty) {
      final initialPrompts = SystemPromptPresets.getInitialPrompts();
      await _systemPromptBox.putAll({
        for (final prompt in initialPrompts) prompt.id: prompt,
      });
    }

    // Update cache when chat box changes
    _chatBox.watch().listen(_onChatBoxEvent);
  }

  void _onChatBoxEvent(BoxEvent event) {
    if (_cachedSessions == null) return;

    if (event.deleted) {
      _cachedSessions!.removeWhere((session) => session.id == event.key);
    } else if (event.value != null) {
      final ChatSession updatedSession = event.value as ChatSession;
      final index = _cachedSessions!
          .indexWhere((session) => session.id == updatedSession.id);

      if (index != -1) {
        final oldSession = _cachedSessions![index];
        _cachedSessions![index] = updatedSession;

        // Only resort if sort key changed
        if (updatedSession.createdAt != oldSession.createdAt) {
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      } else {
        _cachedSessions!.add(updatedSession);
        _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      }
    }
  }

  ValueListenable<Box<ChatSession>> get chatBoxListenable =>
      _chatBox.listenable();

  // Chats
  List<ChatSession> getChatSessions() {
    if (_cachedSessions != null) {
      return UnmodifiableListView(_cachedSessions!);
    }

    _cachedSessions = _chatBox.values.toList()
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));

    return UnmodifiableListView(_cachedSessions!);
  }

  Future<void> saveChatSession(ChatSession session, {bool log = true}) async {
    final isNew = !_chatBox.containsKey(session.id);

    // Optimistic update for immediate UI response
    if (_cachedSessions != null) {
      final index =
          _cachedSessions!.indexWhere((s) => s.id == session.id);
      if (index != -1) {
        _cachedSessions![index] = session;
        // Assume createdAt didn't change for optimization in save path
      } else {
        // If it's a new session, it's likely the newest, so insert at top
        if (_cachedSessions!.isEmpty ||
            session.createdAt.isAfter(_cachedSessions!.first.createdAt) ||
            session.createdAt.isAtSameMomentAs(_cachedSessions!.first.createdAt)) {
          _cachedSessions!.insert(0, session);
        } else {
          _cachedSessions!.add(session);
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      }
    }
    await _chatBox.put(session.id, session);

    if (log && isNew) {
      await logActivity('Chat Created', 'Created new chat (ID: ${session.id}) with model ${session.model}');
    }
  }

  Future<void> deleteChatSession(String id) async {
    // Optimistic update
    if (_cachedSessions != null) {
      _cachedSessions!.removeWhere((s) => s.id == id);
    }
    await _chatBox.delete(id);

    // Remove from pinned list if present
    final pinned = getPinnedChatIds();
    if (pinned.contains(id)) {
      pinned.remove(id);
      await _settingsBox.put(AppConstants.pinnedChatsKey, pinned);
    }

    // Remove tags if present
    final tagsMap = _getChatTagsMap();
    if (tagsMap.containsKey(id)) {
      tagsMap.remove(id);
      await _settingsBox.put(AppConstants.chatTagsKey, tagsMap);
    }

    await logActivity('Chat Deleted', 'Deleted chat (ID: $id)');
  }

  Future<void> clearAllChats() async {
    _cachedSessions = null;
    _cachedTags = null;
    await _chatBox.clear();
    await _settingsBox.delete(AppConstants.pinnedChatsKey);
    await _settingsBox.delete(AppConstants.chatTagsKey);
    await logActivity('History Cleared', 'Deleted all chat history');
  }

  ChatSession? getChatSession(String id) {
    return _chatBox.get(id);
  }

  // System Prompts
  ValueListenable<Box<SystemPrompt>> get promptBoxListenable =>
      _systemPromptBox.listenable();

  ValueListenable<Box> get settingsBoxListenable => _settingsBox.listenable();

  ValueListenable<Box> get starredMessagesListenable =>
      _settingsBox.listenable(keys: [AppConstants.starredMessagesKey]);

  ValueListenable<Box> get activityLogBoxListenable =>
      _activityLogBox.listenable();

  List<SystemPrompt> getSystemPrompts() {
    return _systemPromptBox.values.toList();
  }

  // Search & Filter
  List<ChatSession> searchSessions({
    String query = '',
    String? model,
    DateTime? fromDate,
    String? tag,
  }) {
    List<ChatSession> results = getChatSessions();

    // 0. Filter by Tag
    if (tag != null && tag.isNotEmpty) {
      final tagsMap = _getChatTagsMap();
      results = results.where((s) {
        final sessionTags = tagsMap[s.id];
        return sessionTags != null && sessionTags.contains(tag);
      }).toList();
    }

    // 1. Filter by Query (Title & Content)
    if (query.isNotEmpty) {
      // Use RegExp with caseSensitive: false to avoid allocating lowercased strings
      // for potentially large message content, reducing memory churn during search.
      final queryRegex = RegExp(RegExp.escape(query), caseSensitive: false);
      results = results.where((s) {
        // Check title
        if (queryRegex.hasMatch(s.title)) return true;

        // Check messages content
        for (final message in s.messages) {
          if (queryRegex.hasMatch(message.content)) return true;
        }

        return false;
      }).toList();
    }

    // 2. Filter by Model
    if (model != null && model.isNotEmpty) {
      results = results.where((s) => s.model == model).toList();
    }

    // 3. Filter by Date
    if (fromDate != null) {
      results = results.where((s) => s.createdAt.isAfter(fromDate)).toList();
    }

    return results;
  }

  Set<String> getAvailableModels() {
    return getChatSessions().map((s) => s.model).toSet();
  }

  Future<void> saveSystemPrompt(SystemPrompt prompt) async {
    final isNew = !_systemPromptBox.containsKey(prompt.id);
    await _systemPromptBox.put(prompt.id, prompt);

    if (isNew) {
      await logActivity('System Prompt Created', 'Created system prompt (ID: ${prompt.id})');
    } else {
      await logActivity('System Prompt Updated', 'Updated system prompt (ID: ${prompt.id})');
    }
  }

  Future<void> deleteSystemPrompt(String id) async {
    await _systemPromptBox.delete(id);
    await logActivity('System Prompt Deleted', 'Deleted system prompt (ID: $id)');
  }

  // Settings
  Future<void> saveSetting(String key, dynamic value) async {
    await _settingsBox.put(key, value);
    // Don't log every setting change to avoid noise, or log specific important ones?
    // logging Ollama URL change might be good.
    if (key == AppConstants.ollamaBaseUrlKey) {
       await logActivity('Settings Changed', 'Updated Ollama Base URL');
    }
  }

  dynamic getSetting(String key, {dynamic defaultValue}) {
    return _settingsBox.get(key, defaultValue: defaultValue);
  }

  // Pinned Chats
  List<String> getPinnedChatIds() {
    return List<String>.from(
      _settingsBox.get(AppConstants.pinnedChatsKey, defaultValue: <String>[]),
    );
  }

  bool isPinned(String chatId) {
    final pinned = getPinnedChatIds();
    return pinned.contains(chatId);
  }

  Future<void> togglePin(String chatId) async {
    final pinned = getPinnedChatIds();
    final isPinned = pinned.contains(chatId);

    if (isPinned) {
      pinned.remove(chatId);
      await logActivity('Chat Unpinned', 'Unpinned chat with ID $chatId');
    } else {
      pinned.add(chatId);
      await logActivity('Chat Pinned', 'Pinned chat with ID $chatId');
    }

    await _settingsBox.put(AppConstants.pinnedChatsKey, pinned);
  }

  // Archived Chats
  List<String> getArchivedChatIds() {
    return List<String>.from(
      _settingsBox.get(AppConstants.archivedChatsKey, defaultValue: <String>[]),
    );
  }

  bool isArchived(String chatId) {
    final archived = getArchivedChatIds();
    return archived.contains(chatId);
  }

  Future<void> toggleArchive(String chatId) async {
    final archived = getArchivedChatIds();
    final isArchived = archived.contains(chatId);

    if (isArchived) {
      archived.remove(chatId);
      await logActivity('Chat Unarchived', 'Unarchived chat with ID $chatId');
    } else {
      archived.add(chatId);
      // Unpin if archived
      if (isPinned(chatId)) {
        await togglePin(chatId);
      }
      await logActivity('Chat Archived', 'Archived chat with ID $chatId');
    }

    await _settingsBox.put(AppConstants.archivedChatsKey, archived);
  }

  // Chat Tags
  Map<String, List<String>> _getChatTagsMap() {
    if (_cachedTags != null) return _cachedTags!;

    final rawMap = _settingsBox.get(AppConstants.chatTagsKey, defaultValue: {});
    // Convert dynamic map to Map<String, List<String>>
    if (rawMap is Map) {
      _cachedTags = rawMap.map((key, value) {
        return MapEntry(
          key.toString(),
          (value as List).map((e) => e.toString()).toList(),
        );
      });
    } else {
      _cachedTags = {};
    }
    return _cachedTags!;
  }

  List<String> getTagsForChat(String chatId) {
    final map = _getChatTagsMap();
    return map[chatId] ?? [];
  }

  Set<String> getAllTags() {
    final map = _getChatTagsMap();
    final allTags = <String>{};
    for (final tags in map.values) {
      allTags.addAll(tags);
    }
    return allTags;
  }

  Future<void> addTagToChat(String chatId, String tag) async {
    final map = _getChatTagsMap();
    final tags = map[chatId] ?? [];
    if (!tags.contains(tag)) {
      tags.add(tag);
      map[chatId] = tags;
      await _settingsBox.put(AppConstants.chatTagsKey, map);
      await logActivity('Tag Added', 'Added tag "$tag" to chat $chatId');
    }
  }

  Future<void> removeTagFromChat(String chatId, String tag) async {
    final map = _getChatTagsMap();
    if (map.containsKey(chatId)) {
      final tags = map[chatId]!;
      if (tags.contains(tag)) {
        tags.remove(tag);
        if (tags.isEmpty) {
          map.remove(chatId);
        } else {
          map[chatId] = tags;
        }
        await _settingsBox.put(AppConstants.chatTagsKey, map);
        await logActivity('Tag Removed', 'Removed tag "$tag" from chat $chatId');
      }
    }
  }

  // Message Templates
  List<Map<String, String>> getMessageTemplates() {
    final templates = _settingsBox.get(
      AppConstants.messageTemplatesKey,
      defaultValue: <dynamic>[],
    );
    return (templates as List).map((e) => Map<String, String>.from(e)).toList();
  }

  Future<void> saveMessageTemplate(Map<String, String> template) async {
    final templates = getMessageTemplates();
    final index = templates.indexWhere((t) => t['id'] == template['id']);

    if (index != -1) {
      templates[index] = template;
      await logActivity('Template Updated', 'Updated template "${template['title']}"');
    } else {
      templates.add(template);
      await logActivity('Template Created', 'Created template "${template['title']}"');
    }

    await _settingsBox.put(AppConstants.messageTemplatesKey, templates);
  }

  Future<void> deleteMessageTemplate(String id) async {
    final templates = getMessageTemplates();
    final template = templates.firstWhere(
      (t) => t['id'] == id,
      orElse: () => {},
    );

    if (template.isNotEmpty) {
      templates.removeWhere((t) => t['id'] == id);
      await _settingsBox.put(AppConstants.messageTemplatesKey, templates);
      await logActivity('Template Deleted', 'Deleted template "${template['title']}"');
    }
  }

  // Chat Drafts
  Map<String, String> _getDraftsMap() {
    final rawMap = _settingsBox.get(
      AppConstants.chatDraftsKey,
      defaultValue: <dynamic, dynamic>{},
    );
    return Map<String, String>.from(rawMap);
  }

  Future<void> saveDraft(String chatId, String draft) async {
    // If draft is empty, delete it
    if (draft.trim().isEmpty) {
      await deleteDraft(chatId);
      return;
    }

    final drafts = _getDraftsMap();
    // Only save if changed to reduce writes
    if (drafts[chatId] != draft) {
      drafts[chatId] = draft;
      await _settingsBox.put(AppConstants.chatDraftsKey, drafts);
    }
  }

  String? getDraft(String chatId) {
    final drafts = _getDraftsMap();
    return drafts[chatId];
  }

  Future<void> deleteDraft(String chatId) async {
    final drafts = _getDraftsMap();
    if (drafts.containsKey(chatId)) {
      drafts.remove(chatId);
      await _settingsBox.put(AppConstants.chatDraftsKey, drafts);
    }
  }

  Future<void> clearAllDrafts() async {
    await _settingsBox.delete(AppConstants.chatDraftsKey);
  }

  // Starred Messages
  List<StarredMessage> getStarredMessages() {
    final rawList = _settingsBox.get(
      AppConstants.starredMessagesKey,
      defaultValue: <dynamic>[],
    );
    final messages = (rawList as List)
        .map((e) => StarredMessage.fromJson(Map<String, dynamic>.from(e)))
        .toList();

    _cachedStarredMessages = messages.map((m) => m.message).toSet();
    return messages;
  }

  Future<void> saveStarredMessages(List<StarredMessage> messages) async {
    final rawList = messages.map((m) => m.toJson()).toList();
    await _settingsBox.put(AppConstants.starredMessagesKey, rawList);
    _cachedStarredMessages = messages.map((m) => m.message).toSet();
  }

  Future<void> toggleStarMessage(String chatId, ChatMessage message) async {
    final starred = getStarredMessages();
    final index = starred.indexWhere((s) => s.message == message);

    if (index != -1) {
      // Unstar
      starred.removeAt(index);
      await saveStarredMessages(starred);
      await logActivity('Message Unstarred', 'Unstarred message in chat $chatId');
    } else {
      // Star
      final newStar = StarredMessage(
        id: const Uuid().v4(),
        chatId: chatId,
        message: message,
        starredAt: DateTime.now(),
      );
      starred.add(newStar);
      await saveStarredMessages(starred);
      await logActivity('Message Starred', 'Starred message in chat $chatId');
    }
  }

  bool isMessageStarred(ChatMessage message) {
    if (_cachedStarredMessages == null) {
      getStarredMessages();
    }
    return _cachedStarredMessages!.contains(message);
  }

  Future<void> unstarMessage(String starredMessageId) async {
    final starred = getStarredMessages();
    final initialLength = starred.length;
    starred.removeWhere((s) => s.id == starredMessageId);

    if (starred.length != initialLength) {
      await saveStarredMessages(starred);
      await logActivity('Message Unstarred', 'Unstarred message (ID: $starredMessageId)');
    }
  }

  // Activity Log
  Future<void> logActivity(String action, String details) async {
    final log = {
      'id': const Uuid().v4(),
      'timestamp': DateTime.now().toIso8601String(),
      'action': action,
      'details': details,
    };
    await _activityLogBox.add(log);
  }

  List<Map<String, dynamic>> getActivityLogs() {
    final logs = _activityLogBox.values.map((e) => Map<String, dynamic>.from(e)).toList();
    // Sort by timestamp desc
    logs.sort((a, b) {
      final tA = DateTime.parse(a['timestamp']);
      final tB = DateTime.parse(b['timestamp']);
      return tB.compareTo(tA);
    });
    return logs;
  }

  Future<void> clearActivityLogs() async {
    await _activityLogBox.clear();
    await logActivity('Logs Cleared', 'Cleared activity log history');
  }

  // Export
  Map<String, dynamic> exportData({
    bool includeChats = true,
    bool includePrompts = true,
    bool includeSettings = false,
    List<String>? chatIds,
  }) {
    logActivity(
      'Data Export',
      'Exported data (Chats: $includeChats, Prompts: $includePrompts, Settings: $includeSettings, Selected: ${chatIds?.length ?? 'All'})',
    );

    final Map<String, dynamic> data = {
      'version': 1,
      'timestamp': DateTime.now().toIso8601String(),
    };

    if (includeChats) {
      var sessions = getChatSessions();
      if (chatIds != null) {
        sessions = sessions.where((s) => chatIds.contains(s.id)).toList();
      }
      data['chats'] = sessions.map((s) => _chatSessionToJson(s)).toList();
    }

    if (includePrompts) {
      // Prompts are not filtered by chatIds
      data['prompts'] =
          getSystemPrompts().map((p) => _systemPromptToJson(p)).toList();
    }

    if (includeSettings) {
      data['settings'] = getExportableSettings();
    }

    return data;
  }

  @visibleForTesting
  Map<String, dynamic> getExportableSettings() {
    final Map<String, dynamic> settings = {};

    for (final key in _settingsBox.keys) {
      final String keyStr = key.toString();
      if (allowedSettingsKeys.contains(keyStr) ||
          keyStr.startsWith(AppConstants.modelSettingsPrefixKey)) {
        settings[keyStr] = _settingsBox.get(key);
      }
    }

    return settings;
  }

  String exportToCsv({List<String>? chatIds}) {
    logActivity('Data Export', 'Exported data as CSV');
    final buffer = StringBuffer();
    // Header
    buffer.writeln('ID,Title,Model,Created At,Message Count,System Prompt');

    var sessions = getChatSessions();
    if (chatIds != null) {
      sessions = sessions.where((s) => chatIds.contains(s.id)).toList();
    }

    // Rows
    for (final session in sessions) {
      final id = _escapeCsv(session.id);
      final title = _escapeCsv(session.title);
      final model = _escapeCsv(session.model);
      final createdAt = _escapeCsv(session.createdAt.toIso8601String());
      final msgCount = session.messages.length;
      final sysPrompt = _escapeCsv(session.systemPrompt ?? '');

      buffer.writeln('$id,$title,$model,$createdAt,$msgCount,$sysPrompt');
    }

    return buffer.toString();
  }

  String exportActivityLogsToCsv() {
    logActivity('Data Export', 'Exported activity logs as CSV');
    final buffer = StringBuffer();
    // Header
    buffer.writeln('Timestamp,Action,Details');

    // Rows
    for (final log in getActivityLogs()) {
      final timestamp = _escapeCsv(log['timestamp'] ?? '');
      final action = _escapeCsv(log['action'] ?? '');
      final details = _escapeCsv(log['details'] ?? '');

      buffer.writeln('$timestamp,$action,$details');
    }

    return buffer.toString();
  }

  String exportActivityLogsToJson() {
    logActivity('Data Export', 'Exported activity logs as JSON');
    final logs = getActivityLogs();
    return const JsonEncoder.withIndent('  ').convert(logs);
  }

  Future<Uint8List> exportToPdf({List<String>? chatIds}) async {
    logActivity('Data Export', 'Exported data as PDF');
    var sessions = getChatSessions();
    if (chatIds != null) {
      sessions = sessions.where((s) => chatIds.contains(s.id)).toList();
    }

    return await PdfExportService().generateChatPdf(sessions: sessions);
  }

  String exportToMarkdown({List<String>? chatIds}) {
    logActivity('Data Export', 'Exported data as Markdown');
    final buffer = StringBuffer();
    buffer.writeln('# PocketLLM Lite Chat Export');
    buffer.writeln('Exported on: ${DateTime.now().toString()}\n');

    var sessions = getChatSessions();
    if (chatIds != null) {
      sessions = sessions.where((s) => chatIds.contains(s.id)).toList();
    }

    for (final session in sessions) {
      buffer.writeln('## ${session.title}');
      buffer.writeln('**Model:** ${session.model}');
      buffer.writeln('**Date:** ${session.createdAt.toString()}\n');

      if (session.systemPrompt != null && session.systemPrompt!.isNotEmpty) {
        buffer.writeln('### System Prompt');
        buffer.writeln('> ${session.systemPrompt}\n');
      }

      for (final msg in session.messages) {
        final role = msg.role == 'user' ? 'User' : 'Assistant';
        buffer.writeln('### $role');
        buffer.writeln(_escapeMarkdownContent(msg.content));
      }

      buffer.writeln('---\n');
    }

    return buffer.toString();
  }

  String _escapeMarkdownContent(String content) {
    if (content.isEmpty) return '>\n';
    const prefix = '> ';
    // Split by newline and prepend blockquote prefix to each line
    return content.split('\n').map((line) => '$prefix$line').join('\n') + '\n';
  }

  String _escapeCsv(String field) {
    String escaped = field;
    // Prevent CSV injection (Formula Injection) by prepending a single quote
    // if the field starts with characters that could be interpreted as formulas.
    // Also check for leading whitespace that might hide a formula, and explicit DDE injection chars (\t, \r).
    final trimmed = escaped.trimLeft();
    if (trimmed.startsWith('=') ||
        trimmed.startsWith('+') ||
        trimmed.startsWith('-') ||
        trimmed.startsWith('@') ||
        escaped.startsWith('\t') ||
        escaped.startsWith('\r')) {
      escaped = "'$escaped";
    }

    if (escaped.contains(',') || escaped.contains('"') || escaped.contains('\n')) {
      return '"${escaped.replaceAll('"', '""')}"';
    }
    return escaped;
  }

  Map<String, dynamic> _chatSessionToJson(ChatSession session) {
    return {
      'id': session.id,
      'title': session.title,
      'model': session.model,
      'messages': session.messages.map((m) => _chatMessageToJson(m)).toList(),
      'createdAt': session.createdAt.toIso8601String(),
      'systemPrompt': session.systemPrompt,
      'temperature': session.temperature,
      'topP': session.topP,
      'topK': session.topK,
    };
  }

  Map<String, dynamic> _chatMessageToJson(ChatMessage message) {
    return {
      'role': message.role,
      'content': message.content,
      'timestamp': message.timestamp.toIso8601String(),
      'images': message.images,
    };
  }

  Map<String, dynamic> _systemPromptToJson(SystemPrompt prompt) {
    return {
      'id': prompt.id,
      'title': prompt.title,
      'content': prompt.content,
    };
  }

  // Import
  Future<Map<String, int>> importData(Map<String, dynamic> data) async {
    int chatsImported = 0;
    int promptsImported = 0;
    int settingsImported = 0;

    if (data['chats'] != null) {
      final List chats = data['chats'];
      for (final chatData in chats) {
        try {
          final session = _chatSessionFromJson(chatData);
          await saveChatSession(
            session,
            log: false,
          ); // Don't log individual creates
          chatsImported++;
        } catch (e) {
          debugPrint('Error importing chat: $e');
        }
      }
    }

    if (data['prompts'] != null) {
      final List prompts = data['prompts'];
      for (final promptData in prompts) {
        try {
          final prompt = _systemPromptFromJson(promptData);
          await saveSystemPrompt(
            prompt,
          ); // System prompts are fewer, maybe ok to log? Or supress?
          // I didn't add log arg to saveSystemPrompt, but it's fine.
          promptsImported++;
        } catch (e) {
          debugPrint('Error importing prompt: $e');
        }
      }
    }

    if (data['settings'] != null) {
      final Map<String, dynamic> settings = Map<String, dynamic>.from(
        data['settings'],
      );
      for (final entry in settings.entries) {
        final key = entry.key;
        // Security: Only allow whitelisted keys or model settings
        if (allowedSettingsKeys.contains(key) ||
            key.startsWith(AppConstants.modelSettingsPrefixKey)) {
          await saveSetting(key, entry.value);
          if (key == AppConstants.starredMessagesKey) {
            _cachedStarredMessages = null;
          }
          settingsImported++;
        } else {
          debugPrint('Security: Skipped import of restricted setting key: $key');
        }
      }
    }

    await logActivity(
      'Data Import',
      'Imported $chatsImported chats, $promptsImported prompts, and $settingsImported settings',
    );

    return {
      'chats': chatsImported,
      'prompts': promptsImported,
      'settings': settingsImported,
    };
  }

  ChatSession _chatSessionFromJson(Map<String, dynamic> json) {
    return ChatSession(
      id: json['id'],
      title: json['title'],
      model: json['model'],
      messages: (json['messages'] as List)
          .map((m) => _chatMessageFromJson(m))
          .toList(),
      createdAt: DateTime.parse(json['createdAt']),
      systemPrompt: json['systemPrompt'],
      temperature: json['temperature']?.toDouble(),
      topP: json['topP']?.toDouble(),
      topK: json['topK']?.toInt(),
    );
  }

  ChatMessage _chatMessageFromJson(Map<String, dynamic> json) {
    return ChatMessage(
      role: json['role'],
      content: json['content'],
      timestamp: DateTime.parse(json['timestamp']),
      images:
          json['images'] != null ? List<String>.from(json['images']) : null,
    );
  }

  SystemPrompt _systemPromptFromJson(Map<String, dynamic> json) {
    return SystemPrompt(
      id: json['id'],
      title: json['title'],
      content: json['content'],
    );
  }

  // Statistics
  UsageStatistics getUsageStatistics() {
    final sessions = getChatSessions();
    final totalChats = sessions.length;
    int totalMessages = 0;
    final modelUsage = <String, int>{};
    DateTime? lastActive;

    for (final session in sessions) {
      totalMessages += session.messages.length;

      // Model Usage
      modelUsage[session.model] = (modelUsage[session.model] ?? 0) + 1;

      // Last Active
      if (lastActive == null || session.createdAt.isAfter(lastActive)) {
        lastActive = session.createdAt;
      }
    }

    final totalTokensUsed = getSetting(
      AppConstants.totalTokensUsedKey,
      defaultValue: 0,
    ) as int;

    // Calculate Daily Activity (Last 7 Days)
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final dailyActivity = <DailyActivity>[];

    for (int i = 6; i >= 0; i--) {
      final date = today.subtract(Duration(days: i));
      int chats = 0;
      int messages = 0;

      for (final session in sessions) {
        if (_isSameDay(session.createdAt, date)) {
          chats++;
          messages += session.messages.length;
        }
      }
      dailyActivity.add(DailyActivity(date, chats, messages));
    }

    return UsageStatistics(
      totalChats: totalChats,
      totalMessages: totalMessages,
      totalTokensUsed: totalTokensUsed,
      modelUsage: modelUsage,
      lastActiveDate: lastActive,
      chatsLast7Days: _calculateChatsLast7Days(sessions),
      dailyActivity: dailyActivity,
    );
  }

  int _calculateChatsLast7Days(List<ChatSession> sessions) {
    final now = DateTime.now();
    final sevenDaysAgo = now.subtract(const Duration(days: 7));
    return sessions.where((s) => s.createdAt.isAfter(sevenDaysAgo)).length;
  }

  bool _isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }
}

class UsageStatistics {
  final int totalChats;
  final int totalMessages;
  final int totalTokensUsed;
  final Map<String, int> modelUsage;
  final DateTime? lastActiveDate;
  final int chatsLast7Days;
  final List<DailyActivity> dailyActivity;

  UsageStatistics({
    required this.totalChats,
    required this.totalMessages,
    required this.totalTokensUsed,
    required this.modelUsage,
    this.lastActiveDate,
    required this.chatsLast7Days,
    required this.dailyActivity,
  });

  String get mostUsedModel {
    if (modelUsage.isEmpty) return 'None';
    var maxUsage = 0;
    var topModel = 'None';
    modelUsage.forEach((model, count) {
      if (count > maxUsage) {
        maxUsage = count;
        topModel = model;
      }
    });
    return topModel;
  }
}

class DailyActivity {
  final DateTime date;
  final int chatCount;
  final int messageCount;

  DailyActivity(this.date, this.chatCount, this.messageCount);
}
