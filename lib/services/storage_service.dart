import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';

import '../core/constants/app_constants.dart';
import '../features/chat/domain/models/chat_session.dart';
import '../features/chat/domain/models/chat_message.dart';
import '../features/chat/domain/models/system_prompt.dart';
import '../core/constants/system_prompt_presets.dart';

class StorageService {
  late Box<ChatSession> _chatBox;
  late LazyBox<List<dynamic>> _messagesBox; // Use dynamic because Hive stores lists as such
  late Box<SystemPrompt> _systemPromptBox;
  late Box _settingsBox;
  static const String _messagesBoxName = 'chat_messages';

  // Cache for sorted chat sessions
  List<ChatSession>? _cachedSessions;

  Future<void> init() async {
    await Hive.initFlutter();

    // Adapters will be generated by build_runner
    if (!Hive.isAdapterRegistered(0)) Hive.registerAdapter(ChatMessageAdapter());
    if (!Hive.isAdapterRegistered(1)) Hive.registerAdapter(ChatSessionAdapter());
    if (!Hive.isAdapterRegistered(2)) Hive.registerAdapter(SystemPromptAdapter());

    // IMPORTANT: Open _chatBox as LazyBox first to check for migration without loading everything
    final LazyBox<ChatSession> tempChatBox = await Hive.openLazyBox<ChatSession>(AppConstants.chatBoxName);
    _messagesBox = await Hive.openLazyBox<List<dynamic>>(_messagesBoxName);
    _settingsBox = await Hive.openBox(AppConstants.settingsBoxName);

    await _migrateMessagesIfNeeded(tempChatBox);
    await tempChatBox.close();

    // Now open _chatBox as normal Box
    _chatBox = await Hive.openBox<ChatSession>(AppConstants.chatBoxName);

    _systemPromptBox = await Hive.openBox<SystemPrompt>(
      AppConstants.systemPromptsBoxName,
    );

    // Seed system prompts if empty
    if (_systemPromptBox.isEmpty) {
      final initialPrompts = SystemPromptPresets.getInitialPrompts();
      await _systemPromptBox.putAll({
        for (final prompt in initialPrompts) prompt.id: prompt,
      });
    }

    // Update cache when chat box changes
    _chatBox.watch().listen(_onChatBoxEvent);
  }

  void _onChatBoxEvent(BoxEvent event) {
    if (_cachedSessions == null) return;

    if (event.deleted) {
      _cachedSessions!.removeWhere((session) => session.id == event.key);
    } else if (event.value != null) {
      final ChatSession updatedSession = event.value as ChatSession;
      final index = _cachedSessions!
          .indexWhere((session) => session.id == updatedSession.id);

      if (index != -1) {
        final oldSession = _cachedSessions![index];
        _cachedSessions![index] = updatedSession;

        // Only resort if sort key changed
        if (updatedSession.createdAt != oldSession.createdAt) {
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      } else {
        _cachedSessions!.add(updatedSession);
        _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
      }
    }
  }

  /// Migrates messages from ChatSession objects in _chatBox to _messagesBox.
  Future<void> _migrateMessagesIfNeeded(LazyBox<ChatSession> chatBox) async {
    final bool isMigrated = _settingsBox.get('is_messages_migrated', defaultValue: false);

    if (!isMigrated) {
      // Iterate keys to avoid loading all values
      final keys = chatBox.keys.toList();
      for (final key in keys) {
         final session = await chatBox.get(key);
         if (session != null && session.messages.isNotEmpty) {
           // Move messages
           await _messagesBox.put(session.id, session.messages);

           // Save lite session
           final liteSession = session.copyWith(messages: []);
           await chatBox.put(session.id, liteSession);
         }
      }
      await _settingsBox.put('is_messages_migrated', true);
    }
  }

  ValueListenable<Box<ChatSession>> get chatBoxListenable =>
      _chatBox.listenable();

  // Chats
  /// Returns list of ChatSessions sorted by date.
  /// Note: The returned sessions have EMPTY messages list to save memory.
  /// Use getChatSession(id) to get the full session with messages.
  List<ChatSession> getChatSessions() {
    if (_cachedSessions != null) {
      return UnmodifiableListView(_cachedSessions!);
    }

    _cachedSessions = _chatBox.values.toList()
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));

    return UnmodifiableListView(_cachedSessions!);
  }

  Future<void> saveChatSession(ChatSession session) async {
    // The main branch added optimistic updates to _cachedSessions.
    // I need to preserve that, BUT update it to work with my "lite" sessions.

    // Create the lite session for storage and cache
    final liteSession = session.copyWith(messages: []);

    if (_cachedSessions != null) {
      final index =
          _cachedSessions!.indexWhere((s) => s.id == session.id);
      if (index != -1) {
        // Update with lite session (messages empty)
        _cachedSessions![index] = liteSession;
        // Assume createdAt didn't change for optimization in save path
      } else {
        // If it's a new session, it's likely the newest, so insert at top
        if (_cachedSessions!.isEmpty ||
            session.createdAt.isAfter(_cachedSessions!.first.createdAt) ||
            session.createdAt.isAtSameMomentAs(_cachedSessions!.first.createdAt)) {
          _cachedSessions!.insert(0, liteSession);
        } else {
          _cachedSessions!.add(liteSession);
          _cachedSessions!.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        }
      }
    }

    // Split Storage Logic from my branch
    if (session.messages.isNotEmpty) {
      await _messagesBox.put(session.id, session.messages);
    } else {
       // Check if we have messages stored
       final hasMessages = await _messagesBox.containsKey(session.id);
       if (!hasMessages) {
         // New chat or intentionally empty.
       }
    }

    await _chatBox.put(session.id, liteSession);
  }

  Future<void> deleteChatSession(String id) async {
    // Optimistic update
    if (_cachedSessions != null) {
      _cachedSessions!.removeWhere((s) => s.id == id);
    }
    await _chatBox.delete(id);
    await _messagesBox.delete(id);
  }

  Future<void> clearAllChats() async {
    _cachedSessions = null;
    await _chatBox.clear();
    await _messagesBox.clear();
  }

  /// Retrieves the full ChatSession with messages.
  Future<ChatSession?> getChatSession(String id) async {
    final liteSession = _chatBox.get(id);
    if (liteSession == null) return null;

    final messages = await _messagesBox.get(id);
    final List<ChatMessage> typedMessages = messages?.cast<ChatMessage>().toList() ?? [];

    return liteSession.copyWith(messages: typedMessages);
  }

  // System Prompts
  ValueListenable<Box<SystemPrompt>> get promptBoxListenable =>
      _systemPromptBox.listenable();

  List<SystemPrompt> getSystemPrompts() {
    return _systemPromptBox.values.toList();
  }

  Future<void> saveSystemPrompt(SystemPrompt prompt) async {
    await _systemPromptBox.put(prompt.id, prompt);
  }

  Future<void> deleteSystemPrompt(String id) async {
    await _systemPromptBox.delete(id);
  }

  // Settings
  Future<void> saveSetting(String key, dynamic value) async {
    await _settingsBox.put(key, value);
  }

  dynamic getSetting(String key, {dynamic defaultValue}) {
    return _settingsBox.get(key, defaultValue: defaultValue);
  }
}
